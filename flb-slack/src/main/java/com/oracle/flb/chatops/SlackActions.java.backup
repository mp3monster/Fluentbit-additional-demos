package com.oracle.flb.chatops;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.oracle.FLBCommunication;

import jakarta.ws.rs.client.Client;
import jakarta.ws.rs.client.ClientBuilder;
import jakarta.ws.rs.client.Entity;
import jakarta.ws.rs.client.WebTarget;
import jakarta.ws.rs.core.HttpHeaders;
import jakarta.ws.rs.core.MultivaluedHashMap;
import jakarta.ws.rs.core.Response;

import com.jayway.jsonpath.JsonPath;
import com.jayway.jsonpath.ReadContext;

import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

public class SlackActions {

  private static final String FLB = "FLB:";

  private static class MappedResponse extends HashMap<String, String> {
    public MappedResponse() {
      super();
    }
  };

  // curl -d "channel=CMM13QSBB" -d "limit=3" -d "include_all_metadata=false" -H
  // "Authorization: Bearer
  // xoxb-735037803329-6179690984166-MLSoE7JpBbyIQ2i1MDkFmqQY" -X POST
  // https://slack.com/api/conversations.history

  private String SLACKURL = "https://slack.com/api/conversations.history";
  private String channelId = "CMM13QSBB";
  private String slackToken = "xoxb-735037803329-6179690984166-MLSoE7JpBbyIQ2i1MDkFmqQY";
  private Boolean includeMetadata = Boolean.FALSE;
  private int limit = 3;
  FLBCommunication received = new FLBCommunication();
  private ReadContext jsonCTX = null;

  private MultivaluedHashMap<String, String> initialiseParams() {
    MultivaluedHashMap<String, String> entity = new MultivaluedHashMap<>();
    entity.add("channel", channelId);
    entity.add("limit", Integer.toString(limit));
    entity.add("include_all_metadata", Boolean.toString(includeMetadata));

    // alternative to
    // https://api.slack.com/methods/conversations.history
    return entity;
  }

  private List<MappedResponse> toList(String jsonStr) {
    List<MappedResponse> myList = null;
    received.addRawEvent("toList with " + jsonStr);
    try {
      ObjectMapper objectMapper = new ObjectMapper();
      myList = objectMapper.readValue(jsonStr, new TypeReference<List<MappedResponse>>() {
      });
    } catch (JsonProcessingException jsonErr) {
      received.addRawEvent("toList: using" + jsonStr + "\n" + jsonErr.toString());
      received.setOK(false);
    }
    return myList;
  }

  private String findCommand() {
    String command = null;
    List result = jsonCTX.read("$.messages[*].text");
    if (result.size() > 0) {
      Iterator iter = result.iterator();
      while ((iter.hasNext()) && (command == null)) {
        Object test = iter.next();
        if ((test instanceof String) && (((String) test).startsWith(FLB))) {
          command = ((String) test).substring(FLB.length());
          command.trim();
          if (command.length() == 0) {
            command = null;
          }
        }
      }
    }
    return command;

  }

  private boolean okResponse() {
    Boolean result = jsonCTX.read("$.ok");
    return result.booleanValue();
  }

  private String getCommand(String message) {
    String command = null;
    if ((message != null) && (message.startsWith(FLB))) {
      command = message.substring(FLB.length());
      command = command.trim();
      if (command.length() == 0) {
        command = null;
        received.addRawEvent("found empty command - ignoring");
      }
    }
    return command;
  }

  private MappedResponse toMap(String jsonStr) {
    MappedResponse myMap = new MappedResponse();
    try {
      ObjectMapper objectMapper = new ObjectMapper();
      received.addRawEvent("about to map response");
      myMap = objectMapper.readValue(jsonStr, MappedResponse.class);
    } catch (JsonProcessingException error) {
      received.addRawEvent("toMap:" + error.toString());
      received.setOK(false);
    }
    return myMap;
  }

  public FLBCommunication checkForAction(String alertId) {
    Client client = null;
    String result = "";
    result = ("checkFor Action alertId=" + alertId);
    try {
      client = ClientBuilder.newClient();
      WebTarget target = client.target(SLACKURL);
      Response response = target.request()
          .header(HttpHeaders.AUTHORIZATION, "Bearer " + slackToken)
          .post(Entity.form(initialiseParams()));

      // result = result + "\n" + response.toString();
      Object payloadRaw = response.getEntity();

      received.addRawEvent("raw event:" + payloadRaw.getClass().getName());
      String payload = response.readEntity(String.class);
      client.close();

      MappedResponse mappedResponse = new MappedResponse(); // toMap(payload);
      received.addRawEvent("about to map event ...");
      received.addRawEvent("raw payload ...\n" + payload);
      jsonCTX = JsonPath.parse(payload);
      received.addRawEvent("JsonPath evaluation = " + okResponse());

      if (okResponse()) {
        received.setCommand(findCommand());
      }

    } catch (Exception error) {
      received.addRawEvent(
          "Slack call error for \n:" + error.toString() + alertId + "\n" + error.getStackTrace()[0].toString() + "\n");
    } finally {
      if (client != null) {
        client.close();
      }
    }
    return received;
  }
}
